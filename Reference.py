# (1) Примитивные типы данных
1        # целое число
2.5      # число с плавающей точкой (десятичная дробь)

"string" # Строка - это последовательность символов из таблицы ASCII или символов Юникода
'string' # Полностью аналогично варианту выше
         # Чтобы создать строку нужно обернуть последовательность (возможно пустую) символов в одинарные или двойные ковычки
""       # Тоже строка, просто пустая         

True     # Булева единица (правда)
False    # Булев нуль (неправда)

# (2) Фунцкии, декларирование(создание, определение - синонимы) функций
def myFunc():             # функция без аргументов
    print("1 + 1 =", 2)   # Телом функции явлется весь табулированный код после двоеточия
    # ...

myFunc()  # вызов ранее определенной функции

def myPlus(x, y):         # функция двух аргументов 
    return x + y          # оператор return возвращает обусловленное значение
                          # (в данном случае x + y) 
                          # это можно мыслить себе как подстановку:
                          # myPlus(2, 3) = 2 + 3 = 5
                          # питон подставит (x + y) вместо вызова функции
                          # важно отметить что переменные x, y существуют только внутри тела функции
                          # вне функции они недоступны (и не существуют)


# (3) Операции (операторы и фунции) с примивными типами (примитивами)
# Оператор - встроенная функция нескольких аргуменов которую можно вызвать специальным способом
# Пример:
# 1 + 2 можно мыслить себе как вызов мнимой функции двух аргуметов plus(1, 2) возвращающей сумму своих аргуметов
# (+) - это бинарный оператор, то есть он принимает два аргумента(операнда)

1 + 2
1 - 2
1 * 2
1 / 2  # дробное деление
5 // 2 # целочисленное деление (div)
29 % 7 # остаток от деления (mod)

x = 2 # присвоение переменной x значения 2
      # операторы могут быть унарные (принимают один аргумент)
-x    # унарный оператор, можно мыслить как вызов мнимой функции одного аргумента negate(x)

abs(x)          # модуль числа
int(6.7)        # int(6.7) = 6, превращение аргумента в целое чиcло, выдаст ошибку если превращение невозможно
int("128")      # int("128") = 128
float("5.7e-3") # превращение аргумента в число, float("5.7e-3") = 0.0057 (5.7 * 10^(-3))
2 ** 4          # возведение в степень
pow(2, 4)       # аналогично

# встроенных функций ОЧЕНЬ много, если ищешь что-то конеретное то попробуй просто гуглить или пиши мне

True or False # логическое ИЛИ
True and True # логическое И
not True      # логическое НЕ
# все выше тоже можно мыслить себе как функции над белевыми значениями возвращающие булевы значения

# операторы сравнения:
# операторы сравнения могут принимать разные типы данных (да, и все операторы сравнения - бинарные операторы)
# но возвращают они всегда булево значение (либо программа кидает ошибку если не может сравнить входные данные)
"a" < "b"
1 <= 2
True > False   
48.2 >= 48.2
10 == 10.0000
True != False

# функции над строками
# на самом деле в питоне строки - это объекты некого мнимова класса String (класса всех строк)
# классы можно мыслить себе как множества, а объекты классов - как элементы данных множеств
# в питоне функции определенные внутри класса вызываются специальным образом
# например функция replace определена внутри мнимого класса String поэтому чтобы вызвать ее
# мы пишем не replace("my string", "my", "her") а "my string".replace("my", "her")

"my string".replace("my", "her") == "her string" # замена части строки

# некоторые полезные операции над строками определены вне мнимого класса String
# поэтому вызываем их как обычный вызов функции

len("puppy") == 5 #длинна строки

# причина для такого разделения есть, но об этом позже

"The " + "weather " + "is " + "fine " + "today" == "The weather is fine today" 
"abcd"[0:3] == "abc"
"abcd"[1:4] == "bcd"
"abcdefg"[3:] == "defg"
"abcdefg"[:3] == "abc"
"abcd"[:] == "abcd" #пока не знаю зачем это

# как понять как именно вызывать конкретную операцию (?) - гуглить (но опять же: в разделении есть смысл)

# еще один специальный варант вызова функции:
"cat"[0] == "c" #можно мыслить себе как мнимое index("cat", 0)
"cat" == "cat"[0] + "cat"[1] + "cat"[2]

# (4) условия
myName = "Frank"
if myName == "Owen":
    print("Go away, Owen !")
elif myName == "Frank":
    print("You are welcome here, Frank !")
else:
    print("Who even are you ?")


# еще

if 2 == 2:
    print("true")

# еще

if 2 > 3:
    print("not true")
else:
    print("true")

# Общий вид:    
# if булево значение:
#    тело для обработки правды
# elif еще одно:                        <- вызовется только если if выше не сработал (была ложь)
#    тело для обработки правды
# ...
# else:                                 <- вызовется только если все if и elif выше не сработали
#    тело для обработки всех остальных случаев

# (5) Рекурсия

def factorial(n):
    if n <= 1:
        return 1
    else:
        return n * factorial(n - 1)

factorial(5) == 120
factorial(1) == 1
factorial(0) == 1

def myLen(string):
    if string == "":
        return 0
    else:
        return 1 + myLen(string[1:])

myLen("abcd") == len("abcd")


# (6) Списки

[] # пустой список
[1, 2, 3, 4]
["1", 1, True] # списки могут содержать объекты разных типов

[1, 2, 3][0] == 1
[1, 2, 3][1:] == [2, 3]
len([1, 2, 3]) == 3

[1, 2, 3] + [4, 5, 6] == [1, 2, 3, 4, 5, 6]

# Операции над списками очень похожи на операции над строками
# на самом деле функция len работает как на списках так и на строках
# именно поэтому ее сделали общей и не стали помещать внутрь мнимого класса String
# да, списки тоже можно мыслить себе как объекты мнимого класса List

# (7) Лямбда

f = lambda x: x**2

f(2) == 4

# (8) используем все вместе

def map(list, f):
    if list == []:
        return []
    else:
        first = list[0]
        rest = list[1:]
        return [f(first)] + map(rest, f)

map([1, 2, 3, 4], lambda x: x + 1) == [2, 3, 4, 5]
map([1, 2, 3, 4], lambda x: x ** 2) == [1, 4, 9, 16]

def myAnd(x, y):
   if x == True:
      if y == True:
         return True
      else:
         return False
   else:
         return False
